BLOCK_TEXT = {
    "reportIsA": "is {} a {}?",
    "reportNewList": "new list {}",


    "gotoXY": "go to x: {} y: {}",
    "setHeading": "point in direction {}",
    "doSwitchToCostume": "switch to costume {}",
    "setScale": "set size to {}%",
    "doStamp": "stamp",
    "reportGet": "get {}",
    "doSetVar": "set {} to {}",
    "reportListAttribute": "get attribute {} of list {}",
    "receiveGo": "when I receive Go",
    "setBackgroundColor": "set background color to {}",
    "setSize": "set size to {}",
    "setColor": "set color to {}",
    "reportRandom": "pick random {} to {}",
    "reportRelationTo": "relation to {}",
    "reportListItem": "item {} of list {}",
    "reportQuotient": "quotient of {} and {}",
    "forward": "move {} steps",
    "down": "pen down",
    "up": "pen up",
    "doForever": "forever {}",
    "doRepeat": "repeat {}",
    "doIf": "if {} then {}",
    "doIfElse": "if {} then {} else {}",
    "doElse": "else {}",
    "doStop": "stop {}",
    "doStopAll": "stop all",
    "doStopThis": "stop this script",
    "doStopOthers": "stop other scripts in sprite",
    "doWait": "wait {} secs",
    "doWaitUntil": "wait until {}",
    "doRepeatUntil": "repeat until {}",
  "forward": "move {} steps",
  "doForever": "forever {}",
  "doRepeat": "repeat {}",
  "doIf": "if {} then {}",
  "doIfElse": "if {} then {} else {}",
  "doElse": "else {}",
  "doStop": "stop {}",
  "doStopAll": "stop all",
  "doStopThis": "stop this script",
  "doStopOthers": "stop other scripts in sprite",
  "doWait": "wait {} secs",
  "doWaitUntil": "wait until {}",
  "doRepeatUntil": "repeat until {}",
  "doWhile": "while {} {}",
  "doForEach": "for each {} in {} {}",
  "doStartAsClone": "when I start as a clone",
  "doCreateCloneOf": "create clone of {}",
  "doCreateCloneOfMyself": "create clone of myself",
  "doDeleteClone": "delete this clone",
  "doCounter": "counter",
  "doIncrCounter": "increment counter",
  "doClearCounter": "clear counter",
  "doAllAtOnce": "all at once",
  "doForEachList": "for each {} in {} {}",
  "doSetVar": "set {} to {}",
  "doChangeVar": "change {} by {}",
  "doShowVar": "show {}",
  "doHideVar": "hide {}",
  "doAddToList": "add {} to {}",
  "doDeleteFromList": "delete {} of {}",
  "doDeleteAllFromList": "delete all of {}",
  "doInsertAtList": "insert {} at {} of {}",
  "doReplaceItemInList": "replace item {} of {} with {}",
  "doItemOfList": "item {} of {}",
  "doItemNumOfList": "item # of {} in {}",
  "doLengthOfList": "length of {}",
  "doListContainsItem": "{} contains {}?",
  "doShowList": "show list {}",
  "doHideList": "hide list {}",
  "doIndexAll": "all",
  "doIndexLast": "last",
  "doIndexRandom": "random",
  "doWhenFlagClicked": "when flag clicked",
  "doWhenThisSpriteClicked": "when this sprite clicked",
  "doWhenStageClicked": "when stage clicked",
  "doWhenTouchingObject": "when this sprite touches {}",
  "doWhenBroadcastReceived": "when I receive {}",
  "doWhenBackdropSwitchesTo": "when backdrop switches to {}",
  "doWhenGreaterThan": "when {} > {}",
  "doWhenGreaterThanTimer": "timer",
  "doWhenGreaterThanLoudness": "loudness",
  "doBroadcast": "broadcast {}",
  "doBroadcastAndWait": "broadcast {} and wait",
  "doWhenKeyPressed": "when {} key pressed",
  "doWhenKeyPressedSpace": "space",
  "doWhenKeyPressedLeft": "left arrow",
  "doWhenKeyPressedRight": "right arrow",
  "doWhenKeyPressedDown": "down arrow",
  "doWhenKeyPressedUp": "up arrow",
  "doWhenKeyPressedAny": "any",
  "doSayForSecs": "say {} for {} secs",
  "doSay": "say {}",
  "doHello": "Hello!",
  "doThinkForSecs": "think {} for {} secs",
  "doThink": "think {}",
  "doHmm": "Hmm...",
  "doShow": "show",
  "doHide": "hide",
  "doHideAllSprites": "hide all sprites",
  "doEffectColor": "color",
  "doEffectFisheye": "fisheye",
  "doEffectWhirl": "whirl",
  "doEffectPixelate": "pixelate",
  "doEffectMosaic": "mosaic",
  "doEffectBrightness": "brightness",
  "doEffectGhost": "ghost",
  "doChangeEffectBy": "change {} effect by {}",
  "doSetEffectTo": "set {} effect to {}",
  "doClearGraphicEffects": "clear graphic effects",
  "doChangeSizeBy": "change size by {}",
  "doSetSizeTo": "set size to {} %",
  "doSize": "size",
  "doChangeStretchBy": "change stretch by {}",
  "doSetStretchTo": "set stretch to {} %",
  "doSwitchCostumeTo": "switch costume to {}",
  "doNextCostume": "next costume",
  "doSwitchBackdropTo": "switch backdrop to {}",
  "doGoToFrontBack": "go to {} layer",
  "doGoToFrontBackFront": "front",
  "doGoToFrontBackBack": "back",
  "doGoForwardBackwardLayers": "go {} {} layers",
  "doGoForwardBackwardLayersForward": "forward",
  "doGoForwardBackwardLayersBackward": "backward",
  "doBackdropNumberName": "backdrop {}",
  "doCostumeNumberName": "costume {}",
  "doCostume": "costume",
  "doNumberNameNumber": "number",
  "doNumberNameName": "name",
  "doSwitchBackdropToAndWait": "switch backdrop to {} and wait",
  "doNextBackdropBlock": "next backdrop",
  "doNextBackdrop": "next backdrop",
  "doPreviousBackdrop": "previous backdrop",
  "doRandomBackdrop": "random backdrop",
  "doMoveSteps": "move {} steps",
  "doTurnLeft": "turn left {} degrees",
  "doTurnRight": "turn right {} degrees",
  "doPointInDirection": "point in direction {}",
  "doPointTowards": "point towards {}",
  "doPointTowardsPointer": "mouse-pointer",
  "doPointTowardsRandom": "random direction",
  "doPointTowardsMenu": "point towards {}",
  "doGoTo": "go to {}",
  "doGoToMenu": "go to {}",
  "doGoToPointer": "mouse-pointer",
  "doGoToRandom": "random position",
  "doGoToXY": "go to x: {} y: {}",
  "doGlideSecsToXY": "glide {} secs to x: {} y: {}",
  "doGlideTo": "glide {} secs to {}",
  "doGlideToPointer": "mouse-pointer",
  "doGlideToRandom": "random position",
  "doChangeXBy": "change x by {}",
  "doSetX": "set x to {}",
  "doChangeYBy": "change y by {}",
  "doSetY": "set y to {}",
  "doIfOnEdgeBounce": "if on edge, bounce",
  "doSetRotationStyle": "set rotation style {}",
  "doSetRotationStyleLeftRight": "left-right",
  "doSetRotationStyleDontRotate": "don't rotate",
  "doSetRotationStyleAllAround": "all around",
  "doXPosition": "x position",
  "doYPosition": "y position",
  "doDirection": "direction",
  "doScrollRight": "scroll right {}",
  "doScrollUp": "scroll up {}",
  "doAlignScene": "align scene {}",
  "doAlignSceneBottomLeft": "bottom-left",
  "doAlignSceneBottomRight": "bottom-right",
  "doAlignSceneMiddle": "middle",
  "doAlignSceneTopLeft": "top-left",
  "doAlignSceneTopRight": "top-right",
  "doXScroll": "x scroll",
  "doYScroll": "y scroll",
  "doStageSelected": "Stage selected: no motion blocks",
  "reportVariadicAnd": "(%1) and(%2)",
  "reportVariadicOr": "(%1) or (%2)",
  "reportVariadicSum" :  "sum {}", 
  "reportVariadicDifference": "{} - {}", 
  "reportNot": " not (%1)",
  "doAdd": "(%1) + (%2)",
  "doSubtract": "(%1) - (%2)",
  "doMultiply": "(%1) * (%2)",
  "doDivide": "(%1) / (%2)",
  "doRandom": "pick random (%1) to (%2)",
  "doGT": "(%1) > (%2)",
  "doLT": "(%1) < (%2)",
  "doEquals": "(%1) = (%2)",
  "doAnd": "<%1> and <%2>",
  "doOr": "<%1> or <%2>",
  "doNot": "not <%1>",
  "doJoin": "join (%1) (%2)",
  "doJoinApple": "apple",
  "doJoinBanana": "banana",
  "doLetterOf": "letter (%1) of (%2)",
  "doLetterOfApple": "a",
  "doLength": "length of (%1)",
  "doContains": "(%1) contains (%2)?",
  "doMod": "(%1) mod (%2)",
  "doRound": "round (%1)",
  "doMathOp": "[%1 v] of (%2)",
  "doMathOpAbs": "abs",
  "doMathOpFloor": "floor",
  "doMathOpCeiling": "ceiling",
  "doMathOpSqrt": "sqrt",
  "doMathOpSin": "sin",
  "doMathOpCos": "cos",
  "doMathOpTan": "tan",
  "doMathOpAsin": "asin",
  "doMathOpAcos": "acos",
  "doMathOpAtan": "atan",
  "doMathOpLn": "ln",
  "doMathOpLog": "log",
  "doMathOpEExp": "e ^",
  "doMathOp10Exp": "10 ^",
  "doDefine": "define %1",
  "doTouchingObject": "touching (%1 v)?",
  "doTouchingObjectPointer": "mouse-pointer",
  "doTouchingObjectEdge": "edge",
  "doTouchingColor": "touching color (%1)?",
  "doColorIsTouchingColor": "color (%1) is touching (%2)?",
  "doDistanceTo": "distance to (%1 v)",
  "doDistanceToMenu": "distance to (%1 v)",
  "doDistanceToPointer": "mouse-pointer",
  "doAskAndWait": "ask (%1) and wait",
  "doAskText": "What's your name?",
  "doAnswer": "answer",
  "doKeyPressed": "key (%1 v) pressed?",
  "doMouseDown": "mouse down?",
  "doMouseX": "mouse x",
  "doMouseY": "mouse y",
  "doSetDragMode": "set drag mode [%1 v]",
  "doSetDragModeDraggable": "draggable",
  "doSetDragModeNotDraggable": "not draggable",
  "doLoudness": "loudness",
  "doLoud": "loud?",
  "doTimer": "timer",
  "doResetTimer": "reset timer",
  "doOf": "[%1 v] of (%2 v)",
  "doOfXPosition": "x position",
  "doOfYPosition": "y position",
  "doOfDirection": "direction",
  "doOfCostumeNumber": "costume #",
  "doOfCostumeName": "costume name",
  "doOfSize": "size",
  "doOfVolume": "volume",
  "doOfBackdropNumber": "backdrop #",
  "doOfBackdropName": "backdrop name",
  "doOfStage": "Stage",
  "doOfObjectMenu": "[%1 v] of (%2 v)",
  "doCurrent": "current [%1 v]",
  "doCurrentYear": "year",
  "doCurrentMonth": "month",
  "doCurrentDate": "date",
  "doCurrentDayOfWeek": "day of week",
  "doCurrentHour": "hour",
  "doCurrentMinute": "minute",
  "doCurrentSecond": "second",
  "doDaysSince2000": "days since 2000",
  "doUsername": "username",
  "doUserId": "user id",
  "doKeyOptions": "key (%1 v) pressed?",
  "soundStartSound": "start sound (%1 v)",
  "soundPlayUntilDone": "play sound (%1 v) until done",
  "soundStopAllSounds": "stop all sounds",
  "soundSetEffectTo": "set [%1 v] effect to (%2)",
  "soundChangeEffectBy": "change [%1 v] effect by (%2)",
  "soundClearEffects": "clear sound effects",
  "soundEffectsPitch": "pitch",
  "soundEffectsPan": "pan left/right",
  "soundChangeVolumeBy": "change volume by (%1)",
  "soundSetVolumeTo": "set volume to (%1)%",
  "soundVolume": "volume",
  "soundRecord": "record...",
  "categoryMotion": "Motion",
  "categoryLooks": "Looks",
  "categorySound": "Sound",
  "categoryEvents": "Events",
  "categoryControl": "Control",
  "categorySensing": "Sensing",
  "categoryOperators": "Operators",
  "categoryVariables": "Variables",
  "categoryMyBlocks": "My Blocks",
  "duplicate": "Duplicate",
  "delete": "Delete",
  "addComment": "Add Comment",
  "removeComment": "Remove Comment",
  "deleteBlock": "Delete Block",
  "deleteXBlocks": "Delete %1 Blocks",
  "deleteAllBlocks": "Delete all %1 blocks?",
  "cleanUp": "Clean up Blocks",
  "help": "Help",
  "undo": "Undo",
  "redo": "Redo",
  "editProcedure": "Edit",
  "showProcedureDefinition": "Go to definition",
  "workspaceCommentDefaultText": "Say something...",
  "colourHueLabel": "Color",
  "colourSaturationLabel": "Saturation",
  "colourBrightnessLabel": "Brightness",
  "changeValueTitle": "Change value:",
  "renameVariable": "Rename variable",
  "renameVariableTitle": "Rename all \"%1\" variables to:",
  "renameVariableModalTitle": "Rename Variable",
  "newVariable": "Make a Variable",
  "newVariableTitle": "New variable name:",
  "variableModalTitle": "New Variable",
  "variableAlreadyExists": "A variable named \"%1\" already exists.",
  "variableAlreadyExistsForAnotherType": "A variable named \"%1\" already exists for another variable of type \"%2\".",
  "deleteVariableConfirmation": "Delete %1 uses of the \"%2\" variable?",
  "cannotDeleteVariableProcedure": "Can't delete the variable \"%1\" because it's part of the definition of the function \"%2\"",
  "deleteVariable": "Delete the \"%1\" variable",
  "newProcedure": "Make a Block",
  "procedureAlreadyExists": "A procedure named \"%1\" already exists.",
  "procedureDefaultName": "block name",
  "procedureUsed": "To delete a block definition, first remove all uses of the block",
  "newList": "Make a List",
  "newListTitle": "New list name:",
  "listModalTitle": "New List",
  "listAlreadyExists": "A list named \"%1\" already exists.",
  "renameListTitle": "Rename all \"%1\" lists to:",
  "renameListModalTitle": "Rename List",
  "defaultListItem": "thing",
  "deleteList": "Delete the \"%1\" list",
  "renameList": "Rename list",
  "newBroadcastMessage": "New message",
  "newBroadcastMessageTitle": "New message name:",
  "broadcastModalTitle": "New Message",
  "defaultBroadcastMessageName": "message1",
  "penSetPenColorToColor": "set pen color to (%1)",
  "penSetPenColorParamTo": "set pen (%1 v) to (%2)",
  "penSetPenSizeTo": "set pen size to (%1)",
  "penChangePenColorParamBy": "change pen (%1 v) by (%2)",
  "penChangePenSizeBy": "change pen size by (%1)",
  "penChangePenHueBy": "change color by (%1)",
  "penPenDown": "pen down",
  "penPenUp": "pen up",
  "penClear": "erase all",
  "penStamp": "stamp",
  "soundSoundsMenu": "start sound (%1)",
  "looksBackdrops": "looks_backdrops (%1)",
  "musicChangeTempo": "change tempo by (%1)",
  "musicSetTempoTo": "set tempo to (%1)",
  "musicSetInstrument": "set instrument to (%1 v)",
  "musicPlayNoteForBeats": "play note (%1) for (%2) beats",
  "musicRestForBeats": "rest for (%1) beats",
  "musicPlayDrumForBeats": "play drum (%1 v) for (%2) beats",
  "videoSensingWhenMotionGreaterThan": "when video motion > (%1)",
  "videoSensingVideoOn": "video (%1 v) on (%2 v)",
  "videoSensingVideoToggle": "turn video (%1 v)",
  "videoSensingSetVideoTransparencyTo": "set video transparency to (%1)",
  "translateGetTranslate": "translate (%1) to (%2 v)",
  "text2SpeechSpeakAndWait": "speak (%1)",
  "text2SpeechSetVoice": "set voice to (%1 v)",
  "text2SpeechSetLanguage": "set language to (%1 v)",
  "makeyMakeyWhenCodePressed": "when (%1 v) in order",
  "makeyMakeyKeyPressed": "when (%1 v) key pressed",
  "videoSensingSetVideoTransparency": "when video motion > (%1)",
  "microbitWhenTilted": "when (%1 v) button pressed",
  "microbitButtonPressed": "when (%1 v) button pressed?"
}

STARTER_BLOCKS = {
  "eventWhenFlagClicked": "when green flag clicked",
  "eventWhenThisSpriteClicked": "when this sprite clicked",
  "eventWhenStageClicked": "when stage clicked",
  "eventWhenTouchingObject": "when touching (%1 v)",
  "eventWhenBroadcastReceived": "when I receive (%1 v)",
  "eventWhenBackdropsSwitchesTo": "when backdrop switches to (%1 v)",
  "eventWhenGreaterThan": "when (%1) > (%2)",
  "controlStartAsClone": "when I start as a clone",
  "proceduresDefinition": "define %1"
}



   
    
    



class Script():
    def __init__(self):
        self.script_dict = {}
        self.child_keys = ['SUBSTACK', 'SUBSTACK2']
        self.arg_keys = ['CONDITION','KEY_OPTION']
        self.counter_block = 0
        self.counter_vars = 0
        self.c = 0
        self.vars = {}
        self.blocks = []

    def parser_block(self, block_dict, block_name):
        """
        Searches through each block and outputs a dictionary with all the contents inside the block
        """
        block = block_dict[block_name]
        
        current_counter = self.counter_block

        new_block = {f'block_{self.counter_block}': {"name":block["block"]}}
        self.blocks.append(block["block"])
        self.counter_block += 1
        
        # For custom blocks
        if "mutation" in block and "proccode" in block["mutation"]:
            func_name = block["mutation"]["proccode"]

            n_args = func_name.count('%s') + func_name.count('%n')

            # Create a List with the arguments spots
            args = [f'({i})' for i in range(1, n_args + 1)]

            # Replace the arguments in the function name
            for arg in args:
                if '%s' in func_name:
                    func_name = func_name.replace('%s', arg, 1)
                elif '%n' in func_name:
                    func_name = func_name.replace('%n', arg, 1)

            new_block[f'block_{current_counter}']['func_name'] = func_name

            if "argumentnames" in block["mutation"] and '%s' in func_name:
                list_of_arguments = block["mutation"]["argumentnames"].replace('"', '').strip('][').split(',')
                for arg in list_of_arguments:
                    new_block[f'block_{current_counter}'][f'var_{self.counter_vars}'] = arg

                    self.vars[f'var_{self.counter_vars}'] = arg

                    self.counter_vars += 1

            return new_block

        #For fields (variables)
        n_input = 0
        for input, value in block["fields"].items():
            new_var = value[0]

            new_block[f'block_{current_counter}'][f'var_{self.counter_vars}'] = new_var

            self.vars[f'var_{self.counter_vars}'] = new_var

            self.counter_vars += 1

            n_input += 1
        
        # For inputs that either are another block (with key input_{i}) or just a variable (with key var_{i})
        for input in block["inputs"].keys():
            if input not in self.child_keys:
                value = block["inputs"][input][1]
                if type(value) is str:
                    # Case where there is another block instead of a variable
                    if len(value) == 20 or value in block_dict.keys():
                        new_block[f'block_{current_counter}'][f'input_{n_input}'] = self.parser_block(block_dict, value)
                    else:
                        new_block[f'block_{current_counter}'][f'var_{self.counter_vars}'] = value

                        self.vars[f'var_{self.counter_vars}'] = value

                        self.counter_vars += 1
                else:
                    if (value != None):
                        value = block["inputs"][input][1][1]
                        new_block[f'block_{current_counter}'][f'var_{self.counter_vars}'] = value
                        self.vars[f'var_{self.counter_vars}'] = value
                        self.counter_vars += 1
                n_input += 1
        return new_block

    def parser_script(self, block_dict, start):
        """
        Goes through the json file of a scratch script and outputs a dictionary containing all the blocks and variables of such script
        """
        current = start
        curr_dict = {}
        while True:
            current_block = self.parser_block(block_dict=block_dict, block_name=current)

            #For "if" blocks or "ifelse" blocks
            for i, child_key in enumerate(self.child_keys):
                if child_key in block_dict[current]['inputs']:
                    if block_dict[current]['inputs'][child_key][1]:
                        current_block[[*current_block][0]][f'child_{i}'] = self.parser_script(block_dict, block_dict[current]['inputs'][child_key][1])
                    else:
                        current_block[[*current_block][0]][f'child_{i}'] = None

            curr_dict.update(current_block)

            next_block = block_dict[current]["next"]

            if next_block:
                current = next_block
            else:
                break

        return curr_dict
    
    def set_script_dict(self, block_dict, start):

        self.counter_vars = 0
        self.counter_block = 0
        self.script_dict = self.parser_script(block_dict, start)

    def set_custom_script_dict(self, custom_dict):
        self.script_dict = custom_dict
        return

    def get_vars(self):
        return self.vars
    
    def get_blocks(self):
        return self.blocks
    
    def get_script_dict(self):
        return self.script_dict
    
    def convert_block_to_text(self, block_name):
        """
        Converts an unique block into a text format using the syntax from scratchblocks (https://en.scratch-wiki.info/wiki/Block_Plugin/Syntax)
        """
        print("name:", block_name)
        #name = str(block_name["block"]).upper()
        print("name:", block_name)
        print("name:", block_name.get("block"))
        name = block_name.get("block")
        if name not in BLOCK_TEXT and name not in STARTER_BLOCKS:
            #block_text = block_name["mutation"]["proccode"]
            block_text = block_name["block"]
        else:
            block_text = BLOCK_TEXT[name]
        placeholders = ["%1", "%2", "%3", "%4", "%s"]
        for placeholder in placeholders:
            if placeholder == "%s":
                block_text = block_text.replace(placeholder, "()")
            else:
                block_text = block_text.replace(placeholder, "")
        return block_text

    def convert_to_text(self, indent=0, dict=None):
        """
        Converts a script into a text format using the syntax from scratchblocks (https://en.scratch-wiki.info/wiki/Block_Plugin/Syntax)
        """
        if dict == None:
            self.c = 0
            dict = self.script_dict

        new_text = ""
        for block, item in dict.items():
            block_name = item["name"]

            # Case for custom blocks
            if block_name == "procedures_prototype" or block_name == "procedures_call":
                block_text = item["func_name"]
            elif block_name.upper() not in BLOCK_TEXT:
                block_text = "%1"
            else:
                block_text = BLOCK_TEXT[block_name.upper()]

            n_input = 0

            for i in range(1, 4):
                sub_text =""
                if f'%{i}' not in block_text:
                    continue

                if f"var_{self.c}" in item:
                    sub_text = str(item[f"var_{self.c}"])
                    self.c += 1
                    n_input += 1
                elif f"input_{n_input}" in item:
                    sub_text = self.convert_to_text(indent = 0, dict = item[f"input_{n_input}"])
                    n_input += 1

                block_text = block_text.replace(f'%{i}', sub_text)

                
                
            if len(dict) == 1:
                new_text += block_text
            else:
                new_text += '\n' + block_text

            # For children/inner blocks 
            if "child_0" in item:
                if item["child_0"]:

                    new_text += '\n' + '\t'*indent + self.convert_to_text(indent=indent+1, dict=item["child_0"]) 
                else:
                    new_text += '\n' + '\t'*indent 
                
                if "child_1" in item:
                    if item["child_1"]:
                        new_text += '\n' + 'else' + '\n'+ '\t'*indent + self.convert_to_text(indent=indent+1, dict=item["child_1"]) + '\n' + '\t'*indent + 'end'
                    else:
                        new_text += '\n' + 'else' + '\n' + '\t'*indent + 'end'
                else:
                    new_text += '\n' + '\t'*indent + 'end'

        return new_text